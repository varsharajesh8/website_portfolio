"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-plotly.js";
exports.ids = ["vendor-chunks/react-plotly.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-plotly.js/factory.js":
/*!*************************************************!*\
  !*** ./node_modules/react-plotly.js/factory.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = plotComponentFactory;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\n\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// The naming convention is:\n//   - events are attached as `'plotly_' + eventName.toLowerCase()`\n//   - react props are `'on' + eventName`\nvar eventNames = ['AfterExport', 'AfterPlot', 'Animated', 'AnimatingFrame', 'AnimationInterrupted', 'AutoSize', 'BeforeExport', 'BeforeHover', 'ButtonClicked', 'Click', 'ClickAnnotation', 'Deselect', 'DoubleClick', 'Framework', 'Hover', 'LegendClick', 'LegendDoubleClick', 'Relayout', 'Relayouting', 'Restyle', 'Redraw', 'Selected', 'Selecting', 'SliderChange', 'SliderEnd', 'SliderStart', 'SunburstClick', 'Transitioning', 'TransitionInterrupted', 'Unhover', 'WebGlContextLost'];\nvar updateEvents = ['plotly_restyle', 'plotly_redraw', 'plotly_relayout', 'plotly_relayouting', 'plotly_doubleclick', 'plotly_animated', 'plotly_sunburstclick']; // Check if a window is available since SSR (server-side rendering)\n// breaks unnecessarily if you try to use it server-side.\n\nvar isBrowser = typeof window !== 'undefined';\n\nfunction plotComponentFactory(Plotly) {\n  var PlotlyComponent = /*#__PURE__*/function (_Component) {\n    _inherits(PlotlyComponent, _Component);\n\n    var _super = _createSuper(PlotlyComponent);\n\n    function PlotlyComponent(props) {\n      var _this;\n\n      _classCallCheck(this, PlotlyComponent);\n\n      _this = _super.call(this, props);\n      _this.p = Promise.resolve();\n      _this.resizeHandler = null;\n      _this.handlers = {};\n      _this.syncWindowResize = _this.syncWindowResize.bind(_assertThisInitialized(_this));\n      _this.syncEventHandlers = _this.syncEventHandlers.bind(_assertThisInitialized(_this));\n      _this.attachUpdateEvents = _this.attachUpdateEvents.bind(_assertThisInitialized(_this));\n      _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));\n      _this.handleUpdate = _this.handleUpdate.bind(_assertThisInitialized(_this));\n      _this.figureCallback = _this.figureCallback.bind(_assertThisInitialized(_this));\n      _this.updatePlotly = _this.updatePlotly.bind(_assertThisInitialized(_this));\n      return _this;\n    }\n\n    _createClass(PlotlyComponent, [{\n      key: \"updatePlotly\",\n      value: function updatePlotly(shouldInvokeResizeHandler, figureCallbackFunction, shouldAttachUpdateEvents) {\n        var _this2 = this;\n\n        this.p = this.p.then(function () {\n          if (_this2.unmounting) {\n            return;\n          }\n\n          if (!_this2.el) {\n            throw new Error('Missing element reference');\n          } // eslint-disable-next-line consistent-return\n\n\n          return Plotly.react(_this2.el, {\n            data: _this2.props.data,\n            layout: _this2.props.layout,\n            config: _this2.props.config,\n            frames: _this2.props.frames\n          });\n        }).then(function () {\n          if (_this2.unmounting) {\n            return;\n          }\n\n          _this2.syncWindowResize(shouldInvokeResizeHandler);\n\n          _this2.syncEventHandlers();\n\n          _this2.figureCallback(figureCallbackFunction);\n\n          if (shouldAttachUpdateEvents) {\n            _this2.attachUpdateEvents();\n          }\n        })[\"catch\"](function (err) {\n          if (_this2.props.onError) {\n            _this2.props.onError(err);\n          }\n        });\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.unmounting = false;\n        this.updatePlotly(true, this.props.onInitialized, true);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this.unmounting = false; // frames *always* changes identity so fall back to check length only :(\n\n        var numPrevFrames = prevProps.frames && prevProps.frames.length ? prevProps.frames.length : 0;\n        var numNextFrames = this.props.frames && this.props.frames.length ? this.props.frames.length : 0;\n        var figureChanged = !(prevProps.layout === this.props.layout && prevProps.data === this.props.data && prevProps.config === this.props.config && numNextFrames === numPrevFrames);\n        var revisionDefined = prevProps.revision !== void 0;\n        var revisionChanged = prevProps.revision !== this.props.revision;\n\n        if (!figureChanged && (!revisionDefined || revisionDefined && !revisionChanged)) {\n          return;\n        }\n\n        this.updatePlotly(false, this.props.onUpdate, false);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.unmounting = true;\n        this.figureCallback(this.props.onPurge);\n\n        if (this.resizeHandler && isBrowser) {\n          window.removeEventListener('resize', this.resizeHandler);\n          this.resizeHandler = null;\n        }\n\n        this.removeUpdateEvents();\n        Plotly.purge(this.el);\n      }\n    }, {\n      key: \"attachUpdateEvents\",\n      value: function attachUpdateEvents() {\n        var _this3 = this;\n\n        if (!this.el || !this.el.removeListener) {\n          return;\n        }\n\n        updateEvents.forEach(function (updateEvent) {\n          _this3.el.on(updateEvent, _this3.handleUpdate);\n        });\n      }\n    }, {\n      key: \"removeUpdateEvents\",\n      value: function removeUpdateEvents() {\n        var _this4 = this;\n\n        if (!this.el || !this.el.removeListener) {\n          return;\n        }\n\n        updateEvents.forEach(function (updateEvent) {\n          _this4.el.removeListener(updateEvent, _this4.handleUpdate);\n        });\n      }\n    }, {\n      key: \"handleUpdate\",\n      value: function handleUpdate() {\n        this.figureCallback(this.props.onUpdate);\n      }\n    }, {\n      key: \"figureCallback\",\n      value: function figureCallback(callback) {\n        if (typeof callback === 'function') {\n          var _this$el = this.el,\n              data = _this$el.data,\n              layout = _this$el.layout;\n          var frames = this.el._transitionData ? this.el._transitionData._frames : null;\n          var figure = {\n            data: data,\n            layout: layout,\n            frames: frames\n          };\n          callback(figure, this.el);\n        }\n      }\n    }, {\n      key: \"syncWindowResize\",\n      value: function syncWindowResize(invoke) {\n        var _this5 = this;\n\n        if (!isBrowser) {\n          return;\n        }\n\n        if (this.props.useResizeHandler && !this.resizeHandler) {\n          this.resizeHandler = function () {\n            return Plotly.Plots.resize(_this5.el);\n          };\n\n          window.addEventListener('resize', this.resizeHandler);\n\n          if (invoke) {\n            this.resizeHandler();\n          }\n        } else if (!this.props.useResizeHandler && this.resizeHandler) {\n          window.removeEventListener('resize', this.resizeHandler);\n          this.resizeHandler = null;\n        }\n      }\n    }, {\n      key: \"getRef\",\n      value: function getRef(el) {\n        this.el = el;\n\n        if (this.props.debug && isBrowser) {\n          window.gd = this.el;\n        }\n      } // Attach and remove event handlers as they're added or removed from props:\n\n    }, {\n      key: \"syncEventHandlers\",\n      value: function syncEventHandlers() {\n        var _this6 = this;\n\n        eventNames.forEach(function (eventName) {\n          var prop = _this6.props['on' + eventName];\n          var handler = _this6.handlers[eventName];\n          var hasHandler = Boolean(handler);\n\n          if (prop && !hasHandler) {\n            _this6.addEventHandler(eventName, prop);\n          } else if (!prop && hasHandler) {\n            // Needs to be removed:\n            _this6.removeEventHandler(eventName);\n          } else if (prop && hasHandler && prop !== handler) {\n            // replace the handler\n            _this6.removeEventHandler(eventName);\n\n            _this6.addEventHandler(eventName, prop);\n          }\n        });\n      }\n    }, {\n      key: \"addEventHandler\",\n      value: function addEventHandler(eventName, prop) {\n        this.handlers[eventName] = prop;\n        this.el.on(this.getPlotlyEventName(eventName), this.handlers[eventName]);\n      }\n    }, {\n      key: \"removeEventHandler\",\n      value: function removeEventHandler(eventName) {\n        this.el.removeListener(this.getPlotlyEventName(eventName), this.handlers[eventName]);\n        delete this.handlers[eventName];\n      }\n    }, {\n      key: \"getPlotlyEventName\",\n      value: function getPlotlyEventName(eventName) {\n        return 'plotly_' + eventName.toLowerCase();\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          id: this.props.divId,\n          style: this.props.style,\n          ref: this.getRef,\n          className: this.props.className\n        });\n      }\n    }]);\n\n    return PlotlyComponent;\n  }(_react.Component);\n\n  PlotlyComponent.propTypes = {\n    data: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].object),\n    config: _propTypes[\"default\"].object,\n    layout: _propTypes[\"default\"].object,\n    frames: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].object),\n    revision: _propTypes[\"default\"].number,\n    onInitialized: _propTypes[\"default\"].func,\n    onPurge: _propTypes[\"default\"].func,\n    onError: _propTypes[\"default\"].func,\n    onUpdate: _propTypes[\"default\"].func,\n    debug: _propTypes[\"default\"].bool,\n    style: _propTypes[\"default\"].object,\n    className: _propTypes[\"default\"].string,\n    useResizeHandler: _propTypes[\"default\"].bool,\n    divId: _propTypes[\"default\"].string\n  };\n  eventNames.forEach(function (eventName) {\n    PlotlyComponent.propTypes['on' + eventName] = _propTypes[\"default\"].func;\n  });\n  PlotlyComponent.defaultProps = {\n    debug: false,\n    useResizeHandler: false,\n    data: [],\n    style: {\n      position: 'relative',\n      display: 'inline-block'\n    }\n  };\n  return PlotlyComponent;\n}\n//# sourceMappingURL=factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxvdGx5LmpzL2ZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLDJCQUEyQixzR0FBc0cscUJBQXFCLG1CQUFtQiw4SEFBOEg7O0FBRS9ULDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIscUNBQXFDLG1CQUFPLENBQUMsaUdBQU87O0FBRXBELHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZOztBQUU1RCx1Q0FBdUMsdUNBQXVDOztBQUU5RSxpREFBaUQsZ0RBQWdELHVDQUF1QyxzQ0FBc0Msb0ZBQW9GLDREQUE0RDs7QUFFOVQscURBQXFELDZDQUE2QyxjQUFjLDhFQUE4RSxTQUFTLG9CQUFvQixtREFBbUQsK0JBQStCLHlCQUF5QixpQkFBaUIsc0ZBQXNGLHVCQUF1QiwyRUFBMkUscUZBQXFGLHNDQUFzQyw0Q0FBNEMsT0FBTyw4QkFBOEIseUJBQXlCLGFBQWEsMEJBQTBCOztBQUUzeEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRzs7QUFFeFEsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUcsK0NBQStDLGlCQUFpQixHQUFHOztBQUU1WSxpQ0FBaUMsMEdBQTBHLGlCQUFpQixhQUFhOztBQUV6SyxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZSw0QkFBNEIsbUZBQW1GOztBQUUxUCx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCw4QkFBOEIsdUdBQXVHLG1EQUFtRDs7QUFFeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrS0FBa0s7QUFDbEs7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92YXJzaGFyYWplc2gvRG93bmxvYWRzL3ZhcnNoYS1wb3J0Zm9saW8tdXBkYXRlZDUvbm9kZV9tb2R1bGVzL3JlYWN0LXBsb3RseS5qcy9mYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHBsb3RDb21wb25lbnRGYWN0b3J5O1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBUaGUgbmFtaW5nIGNvbnZlbnRpb24gaXM6XG4vLyAgIC0gZXZlbnRzIGFyZSBhdHRhY2hlZCBhcyBgJ3Bsb3RseV8nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKClgXG4vLyAgIC0gcmVhY3QgcHJvcHMgYXJlIGAnb24nICsgZXZlbnROYW1lYFxudmFyIGV2ZW50TmFtZXMgPSBbJ0FmdGVyRXhwb3J0JywgJ0FmdGVyUGxvdCcsICdBbmltYXRlZCcsICdBbmltYXRpbmdGcmFtZScsICdBbmltYXRpb25JbnRlcnJ1cHRlZCcsICdBdXRvU2l6ZScsICdCZWZvcmVFeHBvcnQnLCAnQmVmb3JlSG92ZXInLCAnQnV0dG9uQ2xpY2tlZCcsICdDbGljaycsICdDbGlja0Fubm90YXRpb24nLCAnRGVzZWxlY3QnLCAnRG91YmxlQ2xpY2snLCAnRnJhbWV3b3JrJywgJ0hvdmVyJywgJ0xlZ2VuZENsaWNrJywgJ0xlZ2VuZERvdWJsZUNsaWNrJywgJ1JlbGF5b3V0JywgJ1JlbGF5b3V0aW5nJywgJ1Jlc3R5bGUnLCAnUmVkcmF3JywgJ1NlbGVjdGVkJywgJ1NlbGVjdGluZycsICdTbGlkZXJDaGFuZ2UnLCAnU2xpZGVyRW5kJywgJ1NsaWRlclN0YXJ0JywgJ1N1bmJ1cnN0Q2xpY2snLCAnVHJhbnNpdGlvbmluZycsICdUcmFuc2l0aW9uSW50ZXJydXB0ZWQnLCAnVW5ob3ZlcicsICdXZWJHbENvbnRleHRMb3N0J107XG52YXIgdXBkYXRlRXZlbnRzID0gWydwbG90bHlfcmVzdHlsZScsICdwbG90bHlfcmVkcmF3JywgJ3Bsb3RseV9yZWxheW91dCcsICdwbG90bHlfcmVsYXlvdXRpbmcnLCAncGxvdGx5X2RvdWJsZWNsaWNrJywgJ3Bsb3RseV9hbmltYXRlZCcsICdwbG90bHlfc3VuYnVyc3RjbGljayddOyAvLyBDaGVjayBpZiBhIHdpbmRvdyBpcyBhdmFpbGFibGUgc2luY2UgU1NSIChzZXJ2ZXItc2lkZSByZW5kZXJpbmcpXG4vLyBicmVha3MgdW5uZWNlc3NhcmlseSBpZiB5b3UgdHJ5IHRvIHVzZSBpdCBzZXJ2ZXItc2lkZS5cblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBwbG90Q29tcG9uZW50RmFjdG9yeShQbG90bHkpIHtcbiAgdmFyIFBsb3RseUNvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhQbG90bHlDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG4gICAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQbG90bHlDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUGxvdGx5Q29tcG9uZW50KHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbG90bHlDb21wb25lbnQpO1xuXG4gICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICAgIF90aGlzLnAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIF90aGlzLnJlc2l6ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgX3RoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgIF90aGlzLnN5bmNXaW5kb3dSZXNpemUgPSBfdGhpcy5zeW5jV2luZG93UmVzaXplLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgX3RoaXMuc3luY0V2ZW50SGFuZGxlcnMgPSBfdGhpcy5zeW5jRXZlbnRIYW5kbGVycy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLmF0dGFjaFVwZGF0ZUV2ZW50cyA9IF90aGlzLmF0dGFjaFVwZGF0ZUV2ZW50cy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLmdldFJlZiA9IF90aGlzLmdldFJlZi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLmhhbmRsZVVwZGF0ZSA9IF90aGlzLmhhbmRsZVVwZGF0ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLmZpZ3VyZUNhbGxiYWNrID0gX3RoaXMuZmlndXJlQ2FsbGJhY2suYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBfdGhpcy51cGRhdGVQbG90bHkgPSBfdGhpcy51cGRhdGVQbG90bHkuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBsb3RseUNvbXBvbmVudCwgW3tcbiAgICAgIGtleTogXCJ1cGRhdGVQbG90bHlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVQbG90bHkoc2hvdWxkSW52b2tlUmVzaXplSGFuZGxlciwgZmlndXJlQ2FsbGJhY2tGdW5jdGlvbiwgc2hvdWxkQXR0YWNoVXBkYXRlRXZlbnRzKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMucCA9IHRoaXMucC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLnVubW91bnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV90aGlzMi5lbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGVsZW1lbnQgcmVmZXJlbmNlJyk7XG4gICAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblxuXG4gICAgICAgICAgcmV0dXJuIFBsb3RseS5yZWFjdChfdGhpczIuZWwsIHtcbiAgICAgICAgICAgIGRhdGE6IF90aGlzMi5wcm9wcy5kYXRhLFxuICAgICAgICAgICAgbGF5b3V0OiBfdGhpczIucHJvcHMubGF5b3V0LFxuICAgICAgICAgICAgY29uZmlnOiBfdGhpczIucHJvcHMuY29uZmlnLFxuICAgICAgICAgICAgZnJhbWVzOiBfdGhpczIucHJvcHMuZnJhbWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpczIudW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzMi5zeW5jV2luZG93UmVzaXplKHNob3VsZEludm9rZVJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgICAgICAgX3RoaXMyLnN5bmNFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAgICAgICBfdGhpczIuZmlndXJlQ2FsbGJhY2soZmlndXJlQ2FsbGJhY2tGdW5jdGlvbik7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQXR0YWNoVXBkYXRlRXZlbnRzKSB7XG4gICAgICAgICAgICBfdGhpczIuYXR0YWNoVXBkYXRlRXZlbnRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLnByb3BzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzMi5wcm9wcy5vbkVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51bm1vdW50aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlUGxvdGx5KHRydWUsIHRoaXMucHJvcHMub25Jbml0aWFsaXplZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy51bm1vdW50aW5nID0gZmFsc2U7IC8vIGZyYW1lcyAqYWx3YXlzKiBjaGFuZ2VzIGlkZW50aXR5IHNvIGZhbGwgYmFjayB0byBjaGVjayBsZW5ndGggb25seSA6KFxuXG4gICAgICAgIHZhciBudW1QcmV2RnJhbWVzID0gcHJldlByb3BzLmZyYW1lcyAmJiBwcmV2UHJvcHMuZnJhbWVzLmxlbmd0aCA/IHByZXZQcm9wcy5mcmFtZXMubGVuZ3RoIDogMDtcbiAgICAgICAgdmFyIG51bU5leHRGcmFtZXMgPSB0aGlzLnByb3BzLmZyYW1lcyAmJiB0aGlzLnByb3BzLmZyYW1lcy5sZW5ndGggPyB0aGlzLnByb3BzLmZyYW1lcy5sZW5ndGggOiAwO1xuICAgICAgICB2YXIgZmlndXJlQ2hhbmdlZCA9ICEocHJldlByb3BzLmxheW91dCA9PT0gdGhpcy5wcm9wcy5sYXlvdXQgJiYgcHJldlByb3BzLmRhdGEgPT09IHRoaXMucHJvcHMuZGF0YSAmJiBwcmV2UHJvcHMuY29uZmlnID09PSB0aGlzLnByb3BzLmNvbmZpZyAmJiBudW1OZXh0RnJhbWVzID09PSBudW1QcmV2RnJhbWVzKTtcbiAgICAgICAgdmFyIHJldmlzaW9uRGVmaW5lZCA9IHByZXZQcm9wcy5yZXZpc2lvbiAhPT0gdm9pZCAwO1xuICAgICAgICB2YXIgcmV2aXNpb25DaGFuZ2VkID0gcHJldlByb3BzLnJldmlzaW9uICE9PSB0aGlzLnByb3BzLnJldmlzaW9uO1xuXG4gICAgICAgIGlmICghZmlndXJlQ2hhbmdlZCAmJiAoIXJldmlzaW9uRGVmaW5lZCB8fCByZXZpc2lvbkRlZmluZWQgJiYgIXJldmlzaW9uQ2hhbmdlZCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVBsb3RseShmYWxzZSwgdGhpcy5wcm9wcy5vblVwZGF0ZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb21wb25lbnRXaWxsVW5tb3VudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnVubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpZ3VyZUNhbGxiYWNrKHRoaXMucHJvcHMub25QdXJnZSk7XG5cbiAgICAgICAgaWYgKHRoaXMucmVzaXplSGFuZGxlciAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVIYW5kbGVyKTtcbiAgICAgICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW1vdmVVcGRhdGVFdmVudHMoKTtcbiAgICAgICAgUGxvdGx5LnB1cmdlKHRoaXMuZWwpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhdHRhY2hVcGRhdGVFdmVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hVcGRhdGVFdmVudHMoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5lbCB8fCAhdGhpcy5lbC5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGVFdmVudCkge1xuICAgICAgICAgIF90aGlzMy5lbC5vbih1cGRhdGVFdmVudCwgX3RoaXMzLmhhbmRsZVVwZGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVVcGRhdGVFdmVudHNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVcGRhdGVFdmVudHMoKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5lbCB8fCAhdGhpcy5lbC5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh1cGRhdGVFdmVudCkge1xuICAgICAgICAgIF90aGlzNC5lbC5yZW1vdmVMaXN0ZW5lcih1cGRhdGVFdmVudCwgX3RoaXM0LmhhbmRsZVVwZGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYW5kbGVVcGRhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZmlndXJlQ2FsbGJhY2sodGhpcy5wcm9wcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZpZ3VyZUNhbGxiYWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlndXJlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfdGhpcyRlbCA9IHRoaXMuZWwsXG4gICAgICAgICAgICAgIGRhdGEgPSBfdGhpcyRlbC5kYXRhLFxuICAgICAgICAgICAgICBsYXlvdXQgPSBfdGhpcyRlbC5sYXlvdXQ7XG4gICAgICAgICAgdmFyIGZyYW1lcyA9IHRoaXMuZWwuX3RyYW5zaXRpb25EYXRhID8gdGhpcy5lbC5fdHJhbnNpdGlvbkRhdGEuX2ZyYW1lcyA6IG51bGw7XG4gICAgICAgICAgdmFyIGZpZ3VyZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgIGZyYW1lczogZnJhbWVzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjYWxsYmFjayhmaWd1cmUsIHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInN5bmNXaW5kb3dSZXNpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jV2luZG93UmVzaXplKGludm9rZSkge1xuICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgICBpZiAoIWlzQnJvd3Nlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLnVzZVJlc2l6ZUhhbmRsZXIgJiYgIXRoaXMucmVzaXplSGFuZGxlcikge1xuICAgICAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQbG90bHkuUGxvdHMucmVzaXplKF90aGlzNS5lbCk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgICAgICAgaWYgKGludm9rZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVIYW5kbGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnByb3BzLnVzZVJlc2l6ZUhhbmRsZXIgJiYgdGhpcy5yZXNpemVIYW5kbGVyKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRSZWZcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWYoZWwpIHtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRlYnVnICYmIGlzQnJvd3Nlcikge1xuICAgICAgICAgIHdpbmRvdy5nZCA9IHRoaXMuZWw7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQXR0YWNoIGFuZCByZW1vdmUgZXZlbnQgaGFuZGxlcnMgYXMgdGhleSdyZSBhZGRlZCBvciByZW1vdmVkIGZyb20gcHJvcHM6XG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic3luY0V2ZW50SGFuZGxlcnNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICAgZXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IF90aGlzNi5wcm9wc1snb24nICsgZXZlbnROYW1lXTtcbiAgICAgICAgICB2YXIgaGFuZGxlciA9IF90aGlzNi5oYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICAgIHZhciBoYXNIYW5kbGVyID0gQm9vbGVhbihoYW5kbGVyKTtcblxuICAgICAgICAgIGlmIChwcm9wICYmICFoYXNIYW5kbGVyKSB7XG4gICAgICAgICAgICBfdGhpczYuYWRkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgcHJvcCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghcHJvcCAmJiBoYXNIYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBOZWVkcyB0byBiZSByZW1vdmVkOlxuICAgICAgICAgICAgX3RoaXM2LnJlbW92ZUV2ZW50SGFuZGxlcihldmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCAmJiBoYXNIYW5kbGVyICYmIHByb3AgIT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgIF90aGlzNi5yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnROYW1lKTtcblxuICAgICAgICAgICAgX3RoaXM2LmFkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIHByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZEV2ZW50SGFuZGxlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIHByb3ApIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyc1tldmVudE5hbWVdID0gcHJvcDtcbiAgICAgICAgdGhpcy5lbC5vbih0aGlzLmdldFBsb3RseUV2ZW50TmFtZShldmVudE5hbWUpLCB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW1vdmVFdmVudEhhbmRsZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFdmVudEhhbmRsZXIoZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMuZWwucmVtb3ZlTGlzdGVuZXIodGhpcy5nZXRQbG90bHlFdmVudE5hbWUoZXZlbnROYW1lKSwgdGhpcy5oYW5kbGVyc1tldmVudE5hbWVdKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0UGxvdGx5RXZlbnROYW1lXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGxvdGx5RXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICAgICAgICByZXR1cm4gJ3Bsb3RseV8nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgIGlkOiB0aGlzLnByb3BzLmRpdklkLFxuICAgICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLFxuICAgICAgICAgIHJlZjogdGhpcy5nZXRSZWYsXG4gICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGxvdGx5Q29tcG9uZW50O1xuICB9KF9yZWFjdC5Db21wb25lbnQpO1xuXG4gIFBsb3RseUNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gICAgZGF0YTogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uYXJyYXlPZihfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5vYmplY3QpLFxuICAgIGNvbmZpZzogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0ub2JqZWN0LFxuICAgIGxheW91dDogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0ub2JqZWN0LFxuICAgIGZyYW1lczogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uYXJyYXlPZihfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5vYmplY3QpLFxuICAgIHJldmlzaW9uOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5udW1iZXIsXG4gICAgb25Jbml0aWFsaXplZDogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uZnVuYyxcbiAgICBvblB1cmdlOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5mdW5jLFxuICAgIG9uRXJyb3I6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gICAgb25VcGRhdGU6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gICAgZGVidWc6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmJvb2wsXG4gICAgc3R5bGU6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgICBjbGFzc05hbWU6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgICB1c2VSZXNpemVIYW5kbGVyOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5ib29sLFxuICAgIGRpdklkOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5zdHJpbmdcbiAgfTtcbiAgZXZlbnROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICBQbG90bHlDb21wb25lbnQucHJvcFR5cGVzWydvbicgKyBldmVudE5hbWVdID0gX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uZnVuYztcbiAgfSk7XG4gIFBsb3RseUNvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZGVidWc6IGZhbHNlLFxuICAgIHVzZVJlc2l6ZUhhbmRsZXI6IGZhbHNlLFxuICAgIGRhdGE6IFtdLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG4gICAgfVxuICB9O1xuICByZXR1cm4gUGxvdGx5Q29tcG9uZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmFjdG9yeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-plotly.js/factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-plotly.js/react-plotly.js":
/*!******************************************************!*\
  !*** ./node_modules/react-plotly.js/react-plotly.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ \"(ssr)/./node_modules/react-plotly.js/factory.js\"));\n\nvar _plotly = _interopRequireDefault(__webpack_require__(/*! plotly.js/dist/plotly */ \"(ssr)/./node_modules/plotly.js/dist/plotly.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar PlotComponent = (0, _factory[\"default\"])(_plotly[\"default\"]);\nvar _default = PlotComponent;\nexports[\"default\"] = _default;\n//# sourceMappingURL=react-plotly.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxvdGx5LmpzL3JlYWN0LXBsb3RseS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLHNDQUFzQyxtQkFBTyxDQUFDLGtFQUFXOztBQUV6RCxxQ0FBcUMsbUJBQU8sQ0FBQyw0RUFBdUI7O0FBRXBFLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy92YXJzaGFyYWplc2gvRG93bmxvYWRzL3ZhcnNoYS1wb3J0Zm9saW8tdXBkYXRlZDUvbm9kZV9tb2R1bGVzL3JlYWN0LXBsb3RseS5qcy9yZWFjdC1wbG90bHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcblxudmFyIF9mYWN0b3J5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9mYWN0b3J5XCIpKTtcblxudmFyIF9wbG90bHkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwbG90bHkuanMvZGlzdC9wbG90bHlcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxudmFyIFBsb3RDb21wb25lbnQgPSAoMCwgX2ZhY3RvcnlbXCJkZWZhdWx0XCJdKShfcGxvdGx5W1wiZGVmYXVsdFwiXSk7XG52YXIgX2RlZmF1bHQgPSBQbG90Q29tcG9uZW50O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXBsb3RseS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-plotly.js/react-plotly.js\n");

/***/ })

};
;